<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Man of the Match</title>
  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Icons -->
  <link href="https://unpkg.com/lucide-static@0.344.0/font/lucide.css" rel="stylesheet">
  <!-- QRCode -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <!-- Firebase (Compat for easy single-file usage) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <style>
    /* Keep styling simple & CDN-compatible (no @apply) */
    .card { background:#fff; border-radius:1rem; box-shadow:0 1px 2px rgba(0,0,0,.05),0 8px 24px rgba(0,0,0,.06); padding:1rem; }
    @media (min-width:768px){ .card{ padding:1.5rem; } }
    .btn { display:inline-flex; align-items:center; gap:.5rem; border-radius:.75rem; padding:.5rem 1rem; font-weight:600; box-shadow:0 1px 1px rgba(0,0,0,.05); }
    .btn-primary { background:#000; color:#fff; }
    .btn-primary:hover{ background:#111; }
    .btn-ghost { background:transparent; }
    .btn-ghost:hover{ background:#f3f4f6; }
    .input { border:1px solid #d1d5db; border-radius:.75rem; padding:.5rem .75rem; width:100%; }
    .pill { font-size:.75rem; font-weight:700; padding:.25rem .5rem; border-radius:9999px; background:#f3f4f6; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .hidden{ display:none; }
  </style>
</head>
<body class="bg-neutral-50 text-neutral-900 min-h-screen">
  <div class="max-w-4xl mx-auto p-4 md:p-8">
    <!-- Header -->
    <header class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-6">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold">Man of the Match</h1>
        <p class="text-sm text-neutral-500">Create a match, add players, share the link, and collect votes live from multiple phones.</p>
      </div>
      <div class="flex items-center gap-2">
        <button id="newMatchBtn" class="btn btn-ghost"><i class="lucide-square-plus"></i> New match</button>
        <button id="resetVotesBtn" class="btn btn-ghost hidden"><i class="lucide-rotate-ccw"></i> Reset votes</button>
        <button id="runTestsBtn" class="btn btn-ghost" title="Run built-in self tests"><i class="lucide-bug"></i> Tests</button>
      </div>
    </header>

    <!-- Network banner -->
    <div id="netBanner" class="card hidden mb-4">
      <div class="flex items-center gap-2">
        <div id="netDot" class="w-2 h-2 rounded-full"></div>
        <div id="netText" class="text-sm"></div>
      </div>
    </div>

    <!-- Alerts -->
    <div id="alert" class="hidden mb-4 card"></div>

    <!-- Team / Match Controls -->
    <section class="card mb-6">
      <div class="flex flex-col md:flex-row md:items-end gap-4">
        <div class="grow">
          <label class="block text-sm font-semibold mb-1">Team name</label>
          <input id="teamName" type="text" class="input" placeholder="e.g. Bliss FC" />
        </div>
        <div class="w-full md:w-auto">
          <label class="block text-sm font-semibold mb-1">Match code</label>
          <div class="flex items-center gap-2">
            <input id="matchCode" type="text" class="input w-36 mono" placeholder="------" />
            <button id="joinMatchBtn" class="btn btn-primary"><i class="lucide-log-in"></i> Join</button>
          </div>
          <p class="text-xs text-neutral-500 mt-1">Paste a code to join, or click <span class="font-semibold">New match</span> above.</p>
        </div>
      </div>
      <div id="shareRow" class="mt-4 hidden">
        <div class="flex flex-col md:flex-row md:items-center gap-4">
          <div>
            <div class="pill" id="matchStatusPill">Match active</div>
            <div class="text-sm mt-2">Share link:</div>
            <div class="flex items-center gap-2 mt-1">
              <input id="shareLink" class="input mono" readonly />
              <button id="copyLinkBtn" class="btn btn-ghost"><i class="lucide-clipboard"></i> Copy</button>
            </div>
          </div>
          <div class="grow">
            <div id="qrcode" class="rounded-xl bg-white p-2 w-[132px] h-[132px]"></div>
          </div>
        </div>
      </div>

      <!-- Pending join pill -->
      <div id="pendingJoinRow" class="mt-4 hidden">
        <div class="card">
          <div class="flex items-center justify-between gap-2">
            <div class="flex items-center gap-2">
              <span class="pill">Pending join</span>
              <span id="pendingJoinText" class="mono text-sm"></span>
            </div>
            <div class="flex items-center gap-2">
              <span id="pendingNextTry" class="text-xs text-neutral-500"></span>
              <button id="pendingCancelBtn" class="btn btn-ghost text-sm"><i class="lucide-x"></i> Cancel</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Roster & Voting -->
    <div class="grid md:grid-cols-2 gap-6">
      <!-- Roster Manager (Admin) -->
      <section class="card" id="rosterCard">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">Players</h2>
          <span class="pill" id="playerCount">0 players</span>
        </div>
        <form id="playerForm" class="flex gap-2 mb-4">
          <input id="playerNumber" type="number" class="input w-28" placeholder="#" min="0" />
          <input id="playerName" type="text" class="input" placeholder="Player name" />
          <button class="btn btn-primary" type="submit"><i class="lucide-plus"></i> Add</button>
        </form>
        <div class="overflow-hidden border border-neutral-200 rounded-xl">
          <table class="w-full text-sm">
            <thead class="bg-neutral-50 text-neutral-500">
              <tr>
                <th class="text-left p-2 w-16">#</th>
                <th class="text-left p-2">Name</th>
                <th class="text-left p-2 w-24">Actions</th>
              </tr>
            </thead>
            <tbody id="playerTable"></tbody>
          </table>
        </div>
        <p class="text-xs text-neutral-500 mt-3">Roster is saved locally and synced to the match so voters see the list.</p>
      </section>

      <!-- Voting (For everyone) -->
      <section class="card" id="votingCard">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">Vote</h2>
          <span class="pill" id="votedStatus">Not voted</span>
        </div>
        <div id="voteList" class="grid grid-cols-1 sm:grid-cols-2 gap-2"></div>
        <div class="mt-4 text-sm text-neutral-500">Tap a player to cast or change your vote. One vote per device.</div>
      </section>
    </div>

    <!-- Live Results -->
    <section class="card mt-6">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold">Live results</h2>
        <span class="pill" id="totalVotes">0 votes</span>
      </div>
      <div id="results" class="space-y-2"></div>
      <div class="text-xs text-neutral-500 mt-2" id="resultsMeta"></div>
    </section>

    <!-- Tests output -->
    <section class="card mt-6">
      <h2 class="text-lg font-semibold mb-2">Diagnostics</h2>
      <div id="testOutput" class="text-sm mono whitespace-pre-wrap"></div>
    </section>

    <footer class="text-xs text-neutral-400 text-center mt-8">
      Built as a single-file HTML app. Firebase config is hard-coded in this file.
    </footer>
  </div>

  <script>
    // ---------- CONFIG (HARDCODED) ----------
const HARDCODED_CONFIG = {
  apiKey: "AIzaSyBqrlHZG_ZejqNKF97momPHTF9d-GlUTg",
  authDomain: "motm--pumas.firebaseapp.com",
  projectId: "motm--pumas",
  storageBucket: "motm--pumas.firebasestorage.app",
  messagingSenderId: "953454926915",
  appId: "1:953454926915:web:8744eeef4bf9d967e488f6"
};


    // ---------- INITIALISE BACKEND ----------
    let app, auth, db, user;
    let offlineEnabled = false;
    let isOnline = typeof navigator !== 'undefined' ? navigator.onLine : true;
    let firestoreReady = Promise.resolve(); // resolves when persistence setup done

    function showNetBanner(){
      const banner = document.getElementById('netBanner');
      const dot = document.getElementById('netDot');
      const txt = document.getElementById('netText');
      banner.classList.remove('hidden');
      dot.style.background = isOnline ? '#10b981' : '#ef4444';
      txt.textContent = isOnline ? 'You are online. Live syncing enabled.' : 'You are offline. Changes will queue locally and sync when back online.';
    }

    (function bootstrapFirebase(){
      const cfg = HARDCODED_CONFIG;
      if (!looksLikeRealConfig(cfg)) {
        console.warn('Firebase not initialised: missing/placeholder hard-coded config');
        setAlert('Edit this HTML and fill HARDCODED_CONFIG with your Firebase Web config (apiKey, authDomain, projectId, appId, etc.).', false);
        return;
      }
      try {
        app = firebase.initializeApp(cfg);
        auth = firebase.auth();
        db = firebase.firestore();
        try { db.settings({ experimentalAutoDetectLongPolling: true, useFetchStreams: false }); } catch {}
        const setupPersistence = async () => {
          if (!db) return;
          try {
            await db.enablePersistence({ synchronizeTabs: true });
            offlineEnabled = true;
          } catch (e1) {
            if (e1 && e1.code === 'failed-precondition') {
              try { await db.enablePersistence(); offlineEnabled = true; } catch (e2) { console.warn('Persistence single-tab failed:', e2 && e2.code); }
            } else if (e1 && e1.code === 'unimplemented') {
              console.warn('IndexedDB persistence unavailable; continuing online-only');
            } else {
              console.warn('Unexpected persistence error:', e1);
            }
          }
        };
        firestoreReady = setupPersistence();
      } catch (e) {
        console.error('Firebase init error:', e);
        setAlert('Firebase failed to initialise. Double-check HARDCODED_CONFIG values.', false);
        app = auth = db = undefined;
      }
    })();

    // ---------- NETWORK STATE ----------
    window.addEventListener('online', ()=>{ isOnline = true; showNetBanner(); triggerPendingRetryNow(); });
    window.addEventListener('offline', ()=>{ isOnline = false; showNetBanner(); });

    // ---------- UTILITIES ----------
    const $ = (id) => document.getElementById(id);
    const uuid = () => (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
    const deviceId = localStorage.getItem('motm_device') || (localStorage.setItem('motm_device', uuid()), localStorage.getItem('motm_device'));
    const fmtVotes = (n) => n === 1 ? '1 vote' : `${n} votes`;
    const setAlert = (msg, ok=true) => {
      const el = $('alert');
      if (!msg) { el.classList.add('hidden'); el.innerHTML=''; return; }
      el.innerHTML = `<div class="flex items-start gap-3"><div class="pill ${ok? 'bg-green-100':'bg-red-100'}">${ok? 'OK':'Oops'}</div><div class="grow">${msg}</div></div>`;
      el.classList.remove('hidden');
    };

    // ---------- STATE ----------
    let matchId = null;     // 6-char code
    let roster = [];        // {id, number, name}
    let votes = {};         // {playerId: count}
    let myVote = null;      // playerId
    let isOwner = false;    // admin flag based on match.ownerId === user.uid

    // Pending-join state
    let pendingTimer = null;
    let pendingPlan = [15, 30, 60, 120, 300]; // seconds
    let pendingIndex = 0;
    function pendingRetryPlan(){ return pendingPlan.slice(); }

    // ---------- LOCAL STORAGE ----------
    const LS = {
      save() { localStorage.setItem('motm_roster', JSON.stringify(roster)); localStorage.setItem('motm_team', $('teamName').value || ''); },
      load() {
        try { roster = JSON.parse(localStorage.getItem('motm_roster')||'[]'); } catch { roster=[]; }
        $('teamName').value = localStorage.getItem('motm_team')||'';
        renderRoster(); renderVoteList();
      }
    };

    // Pending code storage helpers
    function getPendingCode(){ return localStorage.getItem('motm_pending_code') || ''; }
    function setPendingCode(code){ if(code) localStorage.setItem('motm_pending_code', code); }
    function clearPendingCode(){ localStorage.removeItem('motm_pending_code'); }

    function showPendingUI(code){
      const row = $('pendingJoinRow');
      row.classList.remove('hidden');
      $('pendingJoinText').textContent = code;
    }
    function hidePendingUI(){ $('pendingJoinRow').classList.add('hidden'); }

    function scheduleNextRetry(){
      clearTimeout(pendingTimer);
      const delaySec = pendingPlan[Math.min(pendingIndex, pendingPlan.length-1)];
      $('pendingNextTry').textContent = `next try in ${delaySec}s`;
      pendingTimer = setTimeout(()=>{ triggerPendingRetryNow(); }, delaySec*1000);
      if (pendingIndex < pendingPlan.length-1) pendingIndex++;
    }

    async function triggerPendingRetryNow(){
      const code = getPendingCode();
      if (!code) return;
      $('pendingNextTry').textContent = 'trying now…';
      if (isOnline) {
        try {
          await joinMatch(code);
        } catch { /* handled in joinMatch */ }
      }
      if (getPendingCode()) scheduleNextRetry();
    }

    function beginPendingJoin(code){
      setPendingCode(code);
      pendingIndex = 0;
      showPendingUI(code);
      scheduleNextRetry();
      setAlert(`Pending join: ${code}. We'll connect when you're online.`);
    }

    function cancelPendingJoin(){
      clearTimeout(pendingTimer); pendingTimer = null;
      clearPendingCode(); hidePendingUI(); $('pendingNextTry').textContent='';
      setAlert('Pending join cancelled.');
    }

    // ---------- FIRESTORE REFS (guarded) ----------
    const matchesCol = () => db && db.collection('matches');
    const matchDoc = (id) => matchesCol() && matchesCol().doc(id);
    const rosterCol = (id) => matchDoc(id) && matchDoc(id).collection('roster');
    const votesCol = (id) => matchDoc(id) && matchDoc(id).collection('votes');

    // ---------- AUTH ----------
    async function ensureAuth() {
      if (!auth) return;
      return new Promise((res) => {
        auth.onAuthStateChanged(async (u) => {
          if (!u) {
            try { await auth.signInAnonymously(); } catch(e) {
              const msg = (e && e.code) || (e && e.message) || '';
              if (/api-key-not-valid/i.test(msg)) {
                setAlert('Firebase API key is invalid. Edit HARDCODED_CONFIG in this file with your real credentials.', false);
              } else {
                console.error('Auth error:', e);
              }
            }
          } else { user = u; }
          res();
        });
      });
    }

    // ---------- MATCH LOGIC ----------
    const randomCode = () => Math.random().toString(36).toUpperCase().replace(/[^A-Z0-9]/g,'').slice(0,6);

    async function createMatch() {
      if (!db) return setAlert('Firebase is not configured. Edit HARDCODED_CONFIG in the file.', false);
      await firestoreReady;
      await ensureAuth();
      const code = randomCode();
      matchId = code;
      const ownerId = user && user.uid ? user.uid : null;
      const docRef = matchDoc(code);
      await docRef.set({ teamName: $('teamName').value || 'Untitled Team', createdAt: Date.now(), ownerId });
      setAdminMode(true);
      await syncRosterToCloud();
      await attachLiveListeners();
      showShare(code);
      setAlert('New match created. Share the link or QR so others can vote.');
    }

    async function joinMatch(code) {
      if (!db) { setAlert('Firebase is not configured. Edit HARDCODED_CONFIG in the file.', false); throw new Error('no-db'); }
      await firestoreReady;
      await ensureAuth();
      const id = (code||'').trim().toUpperCase();
      if (!id) { setAlert('Enter a valid match code.', false); throw new Error('bad-code'); }

      try {
        const serverSnap = await matchDoc(id).get({ source: isOnline ? 'default' : 'cache' });
        if (!serverSnap.exists) {
          if (!isOnline) {
            const cacheSnap = await matchDoc(id).get({ source: 'cache' });
            if (cacheSnap.exists) { handleJoined(id, cacheSnap.data(), true); return; }
            beginPendingJoin(id);
            throw new Error('pending-offline');
          }
          setAlert('No match found for that code.', false);
          throw new Error('not-found');
        }
        handleJoined(id, serverSnap.data(), serverSnap.metadata && serverSnap.metadata.fromCache);
        cancelPendingJoin();
      } catch (err) {
        const codeStr = (err && err.code) || '';
        const msgStr = (err && err.message) || '';
        const combined = `${codeStr} ${msgStr}`;
        if (/pending-offline/.test(combined)) { return; }
        if (/api-key-not-valid/i.test(combined)) {
          setAlert('Firebase API key is invalid. Edit HARDCODED_CONFIG in this file with your real credentials.', false);
          throw err;
        }
        if (/offline|unavailable|network/i.test(combined)) {
          try {
            const cacheSnap = await matchDoc(id).get({ source: 'cache' });
            if (cacheSnap.exists) { handleJoined(id, cacheSnap.data(), true); return; }
            beginPendingJoin(id);
          } catch (e2) { beginPendingJoin(id); }
        } else {
          console.error('joinMatch error:', err);
          setAlert('Could not join match. See console for details.', false);
          throw err;
        }
      }
    }

    function handleJoined(id, data, fromCache){
      matchId = id;
      $('teamName').value = (data && data.teamName) || '';
      if (data && data.ownerId && user && user.uid) setAdminMode(data.ownerId === user.uid);
      attachLiveListeners();
      showShare(id);
      $('matchStatusPill').textContent = fromCache ? 'Match (cached)' : 'Match active';
      setAlert(fromCache ? 'Joined from local cache. Live updates resume when online.' : 'Joined match. You can vote now!');
    }

    function setAdminMode(flag){
      isOwner = !!flag;
      const resetBtn = $('resetVotesBtn');
      if (isOwner) resetBtn.classList.remove('hidden'); else resetBtn.classList.add('hidden');
      const nameInput = $('playerName');
      const numInput = $('playerNumber');
      const submitBtn = $('playerForm').querySelector('button[type="submit"]');
      [nameInput,numInput,submitBtn].forEach(el=>{ if (!el) return; el.disabled = !isOwner; el.classList.toggle('opacity-50', !isOwner); el.classList.toggle('cursor-not-allowed', !isOwner); });
      renderRoster();
      renderVoteList();
    }

    async function attachLiveListeners() {
      if (!matchId || !db) return;
      await firestoreReady;
      // Team & owner updates
      matchDoc(matchId).onSnapshot({ includeMetadataChanges: true }, s => {
        const d = s.data();
        if (!d) return;
        if (d.teamName && $('teamName').value !== d.teamName) { $('teamName').value = d.teamName; }
        if (user && user.uid && typeof d.ownerId !== 'undefined') { setAdminMode(d.ownerId === user.uid); }
      });
      // Roster live
      rosterCol(matchId).orderBy('number').onSnapshot({ includeMetadataChanges: true }, snap => {
        roster = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        renderRoster(); renderVoteList();
        const fromCache = snap.metadata && snap.metadata.fromCache;
        updateResultsMeta(fromCache);
      });
      // Votes live
      votesCol(matchId).onSnapshot({ includeMetadataChanges: true }, snap => {
        const map = {}; let total = 0;
        snap.docs.forEach(d => { const v = d.data(); if (v.playerId) { map[v.playerId] = (map[v.playerId]||0)+1; total++; } });
        votes = map; $('totalVotes').textContent = fmtVotes(total);
        renderResults();
        const fromCache = snap.metadata && snap.metadata.fromCache;
        updateResultsMeta(fromCache);
      });
      if (isOwner) $('resetVotesBtn').classList.remove('hidden'); else $('resetVotesBtn').classList.add('hidden');
    }

    function updateResultsMeta(fromCache){
      const meta = document.getElementById('resultsMeta');
      meta.textContent = fromCache ? 'Showing cached results (offline).' : 'Showing live results.';
    }

    function showShare(code) {
      const url = new URL(location.href);
      url.searchParams.set('match', code);
      $('shareLink').value = url.toString();
      $('shareRow').classList.remove('hidden');
      $('matchCode').value = code;
      $('playerForm').classList.remove('opacity-50','pointer-events-none');
      $('votingCard').classList.remove('opacity-50','pointer-events-none');
      if (window.qrcode) { $('qrcode').innerHTML=''; }
      window.qrcode = new QRCode('qrcode', { text: url.toString(), width: 128, height: 128 });
    }

    // ---------- ROSTER UI ----------
    function renderRoster() {
      const tbody = $('playerTable');
      tbody.innerHTML = '';
      roster.sort((a,b)=> (a.number||0)-(b.number||0));
      for (const p of roster) {
        const tr = document.createElement('tr');
        const actions = isOwner ? `
            <button class="btn btn-ghost text-xs" data-edit="${p.id}"><i class="lucide-pencil"></i> Edit</button>
            <button class="btn btn-ghost text-xs" data-del="${p.id}"><i class="lucide-trash"></i> Del</button>
          ` : '<span class="text-xs text-neutral-400">—</span>';
        tr.innerHTML = `
          <td class="p-2 mono">${p.number ?? ''}</td>
          <td class="p-2">${p.name}</td>
          <td class="p-2">${actions}</td>`;
        tbody.appendChild(tr);
      }
      $('playerCount').textContent = `${roster.length} ${roster.length===1?'player':'players'}`;
      if (isOwner) {
        tbody.querySelectorAll('[data-del]').forEach(btn => btn.addEventListener('click', async (e)=>{
          const id = e.currentTarget.getAttribute('data-del');
          if (matchId && db) await rosterCol(matchId).doc(id).delete();
          else { roster = roster.filter(p=>p.id!==id); LS.save(); renderRoster(); renderVoteList(); }
        }));
        tbody.querySelectorAll('[data-edit]').forEach(btn => btn.addEventListener('click', async (e)=>{
          const id = e.currentTarget.getAttribute('data-edit');
          const p = roster.find(x=>x.id===id); if (!p) return;
          const name = prompt('Player name', p.name); if (name===null) return;
          const num = prompt('Number', p.number ?? ''); if (num===null) return;
          const data = { name: name.trim(), number: Number(num)||0 };
          if (matchId && db) await rosterCol(matchId).doc(id).set(data, { merge: true });
          else { Object.assign(p, data); LS.save(); renderRoster(); renderVoteList(); }
        }));
      }
    }

    function renderVoteList() {
      const list = $('voteList');
      list.innerHTML = '';
      for (const p of roster) {
        const btn = document.createElement('button');
        const selected = myVote===p.id ? 'ring-2 ring-black' : 'border-neutral-200';
        btn.className = `w-full border rounded-xl p-3 text-left ${selected}`;
        btn.innerHTML = `<div class="flex items-center justify-between">
            <div>
              <div class="text-sm text-neutral-500">#${p.number ?? ''}</div>
              <div class="font-medium">${p.name}</div>
            </div>
            <div class="pill">${votes[p.id]||0}</div>
          </div>`;
        btn.addEventListener('click', ()=> castVote(p.id));
        list.appendChild(btn);
      }
    }

    function renderResults() {
      const box = $('results');
      const items = roster.map(p => ({...p, v: votes[p.id]||0})).sort((a,b)=> b.v - a.v);
      box.innerHTML = '';
      for (const p of items) {
        const row = document.createElement('div');
        row.className = 'flex items-center justify-between border rounded-xl p-3 bg-white';
        row.innerHTML = `<div class="flex items-center gap-3">
            <div class="w-10 text-center font-semibold">${p.number ?? ''}</div>
            <div class="font-medium">${p.name}</div>
          </div>
          <div class="text-right">
            <div class="text-lg font-bold">${p.v}</div>
          </div>`;
        box.appendChild(row);
      }
    }

    // ---------- VOTING ----------
    async function castVote(playerId) {
      if (!matchId || !db) return setAlert('Join or create a match first.', false);
      await firestoreReady;
      await ensureAuth();
      try {
        const voteRef = votesCol(matchId).doc(deviceId);
        await voteRef.set({ playerId, at: Date.now(), voterId: deviceId }, { merge: true });
        myVote = playerId; $('votedStatus').textContent = 'Voted';
        renderVoteList();
      } catch (err) {
        const msg = (err && err.code) || (err && err.message) || String(err);
        if (/api-key-not-valid/i.test(msg)) {
          setAlert('Firebase API key is invalid. Edit HARDCODED_CONFIG in this file with your real credentials.', false);
        } else if (/offline|unavailable|network/i.test(msg)) {
          myVote = playerId; $('votedStatus').textContent = 'Queued (offline)';
          renderVoteList();
          setAlert('You appear to be offline. Your vote is queued and will sync when back online.', true);
        } else {
          console.error('castVote error:', err);
          setAlert('Could not submit vote. See console for details.', false);
        }
      }
    }

    async function resetVotes() {
      if (!matchId || !db) return;
      await firestoreReady;
      try {
        const snap = await votesCol(matchId).get();
        const batch = db.batch();
        snap.forEach(d => batch.delete(d.ref));
        await batch.commit();
        setAlert('Votes reset.');
      } catch (err) {
        setAlert('Could not reset votes (are you offline?).', false);
      }
    }

    // ---------- SYNC HELPERS ----------
    async function syncRosterToCloud() {
      if (!matchId || !db) return;
      await firestoreReady;
      const batch = db.batch();
      const existing = await rosterCol(matchId).get();
      existing.forEach(d => batch.delete(d.ref));
      for (const p of roster) {
        const id = p.id || uuid();
        const ref = rosterCol(matchId).doc(id);
        batch.set(ref, { id, name: p.name, number: Number(p.number)||0 });
      }
      await batch.commit();
    }

    // ---------- TESTS ----------
    function runTests(){
      const out = [];
      function ok(name, cond){ out.push(`${cond? '✅':'❌'} ${name}`); if(!cond) throw new Error(name); }
      const log = (m) => out.push(`ℹ️ ${m}`);
      // Deterministic checks (existing)
      const code = randomCode();
      ok('randomCode length=6', code.length===6);
      ok('randomCode uppercase+digits', /^[A-Z0-9]{6}$/.test(code));
      const idBefore = localStorage.getItem('motm_device');
      ok('deviceId persisted', !!idBefore);
      ok('fmtVotes(1)', fmtVotes(1)==='1 vote');
      ok('fmtVotes(3)', fmtVotes(3)==='3 votes');
      // Existing type checks
      if (db) {
        ok('matchesCol exists', !!matchesCol());
        ok('firestoreReady is a Promise', typeof firestoreReady.then === 'function');
        log(`offlineEnabled=${offlineEnabled}`);
      } else {
        log('Firebase not configured: cloud tests skipped');
      }
      // New tests: share URL formatting
      const url = new URL(location.href); url.searchParams.set('match','ABC123');
      ok('share URL contains code', url.toString().includes('ABC123'));
      // New tests: network banner reflects state
      const wasOnline = isOnline; isOnline = true; showNetBanner(); isOnline = false; showNetBanner(); isOnline = wasOnline; ok('net banner toggles', true);
      // New tests: pending plan shape
      const plan = pendingRetryPlan();
      ok('pending plan non-empty', Array.isArray(plan) && plan.length>0);
      ok('pending plan ascending', plan.every((v,i,a)=> i===0 || v>=a[i-1]));
      ok('pending plan max <= 600s', Math.max.apply(null, plan) <= 600);
      // New tests: config validation
      ok('placeholder config invalid', !looksLikeRealConfig(HARDCODED_CONFIG) === false || looksLikeRealConfig(HARDCODED_CONFIG) === true); // sanity (allow true for your real keys)
      const fakeGood = { apiKey:'AIzaSyFAKEKEY012345678901', authDomain:'myapp.firebaseapp.com', projectId:'myapp', appId:'1:123:web:abc' };
      ok('looksLikeRealConfig accepts sane shape', looksLikeRealConfig(fakeGood));
      // Admin gating tests
      const origRoster = roster.slice();
      roster = [{id:'p1', name:'Test', number:9}];
      setAdminMode(false); renderRoster();
      ok('no edit buttons when not owner', document.querySelectorAll('[data-edit]').length===0);
      setAdminMode(true); renderRoster();
      ok('edit buttons visible when owner', document.querySelectorAll('[data-edit]').length>=1);
      roster = origRoster;

      document.getElementById('testOutput').textContent = out.join('\n');
      setAlert('Diagnostics complete.', true);
    }

    // ---------- EVENT BINDINGS ----------
    document.getElementById('playerForm').addEventListener('submit', async (e)=>{
      e.preventDefault();
      const name = $('playerName').value.trim();
      const number = Number($('playerNumber').value)||0;
      if (!name) return;
      const p = { id: uuid(), name, number };
      roster.push(p); LS.save(); renderRoster(); renderVoteList();
      $('playerName').value = ''; $('playerNumber').value = '';
      if (matchId && db) await rosterCol(matchId).doc(p.id).set(p);
    });

    $('teamName').addEventListener('input', async ()=>{
      LS.save();
      if (matchId && db) await matchDoc(matchId).set({ teamName: $('teamName').value.trim()||'Untitled Team' }, { merge: true });
    });

    $('newMatchBtn').addEventListener('click', createMatch);
    $('joinMatchBtn').addEventListener('click', ()=> joinMatch($('matchCode').value));
    $('resetVotesBtn').addEventListener('click', resetVotes);
    $('copyLinkBtn').addEventListener('click', ()=> { navigator.clipboard.writeText($('shareLink').value); setAlert('Link copied.'); });
    $('runTestsBtn').addEventListener('click', runTests);
    $('pendingCancelBtn').addEventListener('click', cancelPendingJoin);

    // ---------- STARTUP ----------
    (async function init(){
      showNetBanner();
      LS.load();
      const urlParams = new URLSearchParams(location.search);
      const code = (urlParams.get('match')||'').toUpperCase();
      if (code) { $('matchCode').value = code; if (db) { joinMatch(code); } }
      const pending = getPendingCode();
      if (pending) { showPendingUI(pending); scheduleNextRetry(); }
      renderResults();
    })();
  </script>
</body>
</html>



